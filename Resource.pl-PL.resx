<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="absError1" xml:space="preserve">
    <value>Błąd bezwzględny:</value>
  </data>
  <data name="absoluteErrorLabel" xml:space="preserve">
    <value>Błąd bezwzględny:</value>
  </data>
  <data name="accuracyLabel" xml:space="preserve">
    <value>Dokładnośc:</value>
  </data>
  <data name="addBtn" xml:space="preserve">
    <value>Dodaj</value>
  </data>
  <data name="addMsg" xml:space="preserve">
    <value>Dodano punkt </value>
  </data>
  <data name="appNumber" xml:space="preserve">
    <value>Liczba przybliżona:</value>
  </data>
  <data name="approxfuncBnt" xml:space="preserve">
    <value>Aproksymacje</value>
  </data>
  <data name="approxFuncTask1Task" xml:space="preserve">
    <value>Napisz i uruchom aplikację komputerową, która na podstawie danych z poniższej tabeli:
i xi yi
1 2 2.5
2 4 10
3 6 32
4 8 40
5 10 60
znajdzie liniową funkcję aproksymacyjną</value>
  </data>
  <data name="approxFuncTitle" xml:space="preserve">
    <value>Aproksymacje</value>
  </data>
  <data name="approximationsBtn" xml:space="preserve">
    <value>Przybliżenia</value>
  </data>
  <data name="approxTitle" xml:space="preserve">
    <value>Przybiżenia</value>
  </data>
  <data name="appValue1" xml:space="preserve">
    <value>Wartość przybliżona: </value>
  </data>
  <data name="backBtn" xml:space="preserve">
    <value>Powrót</value>
  </data>
  <data name="backwardBtn" xml:space="preserve">
    <value>Różnice wsteczne</value>
  </data>
  <data name="calculateBtn" xml:space="preserve">
    <value>Oblicz</value>
  </data>
  <data name="coefficientsLabel" xml:space="preserve">
    <value>Współczynniki:</value>
  </data>
  <data name="column" xml:space="preserve">
    <value>Kolumna</value>
  </data>
  <data name="different" xml:space="preserve">
    <value>Różnica</value>
  </data>
  <data name="differentiationBtn" xml:space="preserve">
    <value>Różniczkowanie</value>
  </data>
  <data name="differentiationTask" xml:space="preserve">
    <value>Napisz i uruchom aplikację komputerową pobierający co najmniej cztery pary punktów (x, f(x)),
a następnie obliczającą:
1. różnice progresywne,
2. różnice wsteczne,
3. ilorazy różnicowe
pomiędzy odpowiednimi parami punktów. Jeżeli wykonanie tej operacji jest niemożliwe program
powinien poinformować o tym użytkownika.</value>
  </data>
  <data name="differentiationTitle" xml:space="preserve">
    <value>Różniczkowanie</value>
  </data>
  <data name="dividedBtn" xml:space="preserve">
    <value>Ilorazy różnicowe</value>
  </data>
  <data name="errorMsg" xml:space="preserve">
    <value>Nieprawidłowe wartości x lub y. Sprawdź wprowadzone dane.</value>
  </data>
  <data name="exNumber" xml:space="preserve">
    <value>Liczba dokładna:</value>
  </data>
  <data name="formTitle" xml:space="preserve">
    <value>Wstęp do metod numerycznych</value>
  </data>
  <data name="integrationsBtn" xml:space="preserve">
    <value>Całkowanie</value>
  </data>
  <data name="integrationsTask" xml:space="preserve">
    <value>Napisz i uruchom aplikację komputerową obliczająca wartość całki z wielomianu W(x) rzędu co
najmniej trzeciego i zdefiniowanego na zadanym przedziale [a, b] trzema metodami:
1. metodą prostokątów,
2. metodą trapezów,
3. metodą parabol,
z zadaną z góry dokładnością. Porównaj i przeanalizuj otrzymane wyniki oraz efektywność tych
metod (np. liczbę wykonanych iteracji do osiągnięcia pożądanej dokładności).</value>
  </data>
  <data name="integrationsTitle" xml:space="preserve">
    <value>Całkowanie</value>
  </data>
  <data name="interLabel" xml:space="preserve">
    <value />
  </data>
  <data name="interpolationsBtn" xml:space="preserve">
    <value>Interpolacje</value>
  </data>
  <data name="interpolationTitle" xml:space="preserve">
    <value>Interpolacje</value>
  </data>
  <data name="interTaskText" xml:space="preserve">
    <value>Napisz i uruchom aplikację komputerową, która na podstawie wprowadzonych czterech par wielkości
(x, f(x)) znajduje wielomian interpolacyjny trzeciego stopnia przybliżający tę funkcję f(x).Jeżeli
wykonanie tej operacji jest niemożliwe, to program powinien poinformować o tym użytkownika.</value>
  </data>
  <data name="invalidValues" xml:space="preserve">
    <value>Błędne dane</value>
  </data>
  <data name="iterationsTxt" xml:space="preserve">
    <value>Liczba iteracji:</value>
  </data>
  <data name="languageBtn" xml:space="preserve">
    <value>Zmień język</value>
  </data>
  <data name="notEnoughtMsg" xml:space="preserve">
    <value>Potrzebujesz co najmniej dwóch punktów do obliczeń różnic progresywnych.</value>
  </data>
  <data name="overestimationText" xml:space="preserve">
    <value>Przybliżenie z nadmiarem: </value>
  </data>
  <data name="parabolicMethodBtn" xml:space="preserve">
    <value>Metoda parabol</value>
  </data>
  <data name="parabolicTitle" xml:space="preserve">
    <value>Metoda parabol</value>
  </data>
  <data name="progressiveBtn" xml:space="preserve">
    <value>Różnice progresywne</value>
  </data>
  <data name="progressiveTitle" xml:space="preserve">
    <value>Różnice progresywne</value>
  </data>
  <data name="rectangleMethodBtn" xml:space="preserve">
    <value>Metoda prostokątów</value>
  </data>
  <data name="rectangleTitle" xml:space="preserve">
    <value>Metoda prostokątów</value>
  </data>
  <data name="relativeErrorLabel" xml:space="preserve">
    <value>Błąd względny:</value>
  </data>
  <data name="resultTextLabel" xml:space="preserve">
    <value>Wynik: </value>
  </data>
  <data name="resultTxt" xml:space="preserve">
    <value>Wartość całki:</value>
  </data>
  <data name="task11Btn" xml:space="preserve">
    <value>Zadanie 1</value>
  </data>
  <data name="task11Task" xml:space="preserve">
    <value>Napisz i uruchom aplikację komputerową obliczającą błąd względny i bezwzględny po wprowadzeniu dwu liczb: dokładnej i przybliżonej.</value>
  </data>
  <data name="task12Btn" xml:space="preserve">
    <value>Zadanie 2</value>
  </data>
  <data name="task12Task" xml:space="preserve">
    <value>Napisz i uruchom aplikację komputerową znajdująca dokładną wartość liczby, jeśli wprowadzimy
jej wartość przybliżoną i jej błąd bezwzględny dla dwu przypadków:
1. liczba jest przybliżeniem z niedomiarem,
2. liczba jest przybliżeniem z nadmiarem.</value>
  </data>
  <data name="Task31Task" xml:space="preserve">
    <value>Napisz i uruchom aplikację komputerową, która na podstawie poniższych danych:
(0.955, 5.722), (1.38, 4.812), (1.854, 4.727), (2.093, 4.850), (2.674, 5.011), (3.006, 5.253), (3.255,
5.617), (3.940, 6.282), (4.060, 6.255)
używając jako funkcji bazowych następujących funkcji: 1/x , x , x2, znajdzie funkcję aproksymacyjną.</value>
  </data>
  <data name="trapezoidalMethodBtn" xml:space="preserve">
    <value>Metoda trapezów</value>
  </data>
  <data name="trapezTitle" xml:space="preserve">
    <value>Metoda trapezów</value>
  </data>
  <data name="underestimationText" xml:space="preserve">
    <value>Przybliżenie z niedomiarem: </value>
  </data>
</root>